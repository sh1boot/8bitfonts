#include <unistd.h>

#include <cassert>
#include <cstdio>
#include <cstdint>
#include <cstdlib>
#include <array>
#include <filesystem>
#include <iostream>
#include <iomanip>
#include <map>
#include <string>
#include <span>
#include <vector>

/*
â–‘â”€â–‘â”â–‘â”‚â–‘â”ƒâ–‘â”„â–‘â”…â–‘â”†â–‘â”‡â–‘â”ˆâ–‘â”‰â–‘â”Šâ–‘â”‹â–‘â”Œâ–‘â”â–‘â”â–‘â”â–‘â”â–‘â”‘â–‘â”’â–‘â”“â–‘â””â–‘â”•â–‘â”–â–‘â”—â–‘â”˜â–‘â”™â–‘â”šâ–‘â”›â–‘â”œâ–‘â”â–‘â”â–‘â”Ÿâ–‘â–‘
â–‘â–‘â” â–‘â”¡â–‘â”¢â–‘â”£â–‘â”¤â–‘â”¥â–‘â”¦â–‘â”§â–‘â”¨â–‘â”©â–‘â”ªâ–‘â”«â–‘â”¬â–‘â”­â–‘â”®â–‘â”¯â–‘â”°â–‘â”±â–‘â”²â–‘â”³â–‘â”´â–‘â”µâ–‘â”¶â–‘â”·â–‘â”¸â–‘â”¹â–‘â”ºâ–‘â”»â–‘â”¼â–‘â”½â–‘â”¾â–‘â”¿â–‘
â–‘â•€â–‘â•â–‘â•‚â–‘â•ƒâ–‘â•„â–‘â•…â–‘â•†â–‘â•‡â–‘â•ˆâ–‘â•‰â–‘â•Šâ–‘â•‹â–‘â•Œâ–‘â•â–‘â•â–‘â•â–‘â•â–‘â•‘â–‘â•’â–‘â•“â–‘â•”â–‘â••â–‘â•–â–‘â•—â–‘â•˜â–‘â•™â–‘â•šâ–‘â•›â–‘â•œâ–‘â•â–‘â•â–‘â•Ÿâ–‘â–‘
â–‘â–‘â• â–‘â•¡â–‘â•¢â–‘â•£â–‘â•¤â–‘â•¥â–‘â•¦â–‘â•§â–‘â•¨â–‘â•©â–‘â•ªâ–‘â•«â–‘â•¬â–‘â•­â–‘â•®â–‘â•¯â–‘â•°â–‘â•±â–‘â•²â–‘â•³â–‘â•´â–‘â•µâ–‘â•¶â–‘â•·â–‘â•¸â–‘â•¹â–‘â•ºâ–‘â•»â–‘â•¼â–‘â•½â–‘â•¾â–‘â•¿â–‘
â–‘â–€â–‘â–â–‘â–‚â–‘â–ƒâ–‘â–„â–‘â–…â–‘â–†â–‘â–‡â–‘â–ˆâ–‘â–‰â–‘â–Šâ–‘â–‹â–‘â–Œâ–‘â–â–‘â–â–‘â–â–‘â–â–‘â–‘â–‘â–’â–‘â–“â–‘â–”â–‘â–•â–‘â––â–‘â–—â–‘â–˜â–‘â–™â–‘â–šâ–‘â–›â–‘â–œâ–‘â–â–‘â–â–‘â–Ÿâ–‘â–‘
â–‘â–‘ğŸ¬€â–‘ğŸ¬â–‘ğŸ¬‚â–‘ğŸ¬ƒâ–‘ğŸ¬„â–‘ğŸ¬…â–‘ğŸ¬†â–‘ğŸ¬‡â–‘ğŸ¬ˆâ–‘ğŸ¬‰â–‘ğŸ¬Šâ–‘ğŸ¬‹â–‘ğŸ¬Œâ–‘ğŸ¬â–‘ğŸ¬â–‘ğŸ¬â–‘ğŸ¬â–‘ğŸ¬‘â–‘ğŸ¬’â–‘ğŸ¬“â–‘ğŸ¬”â–‘ğŸ¬•â–‘ğŸ¬–â–‘ğŸ¬—â–‘ğŸ¬˜â–‘ğŸ¬™â–‘ğŸ¬šâ–‘ğŸ¬›â–‘ğŸ¬œâ–‘ğŸ¬â–‘ğŸ¬â–‘ğŸ¬Ÿâ–‘
â–‘ğŸ¬ â–‘ğŸ¬¡â–‘ğŸ¬¢â–‘ğŸ¬£â–‘ğŸ¬¤â–‘ğŸ¬¥â–‘ğŸ¬¦â–‘ğŸ¬§â–‘ğŸ¬¨â–‘ğŸ¬©â–‘ğŸ¬ªâ–‘ğŸ¬«â–‘ğŸ¬¬â–‘ğŸ¬­â–‘ğŸ¬®â–‘ğŸ¬¯â–‘ğŸ¬°â–‘ğŸ¬±â–‘ğŸ¬²â–‘ğŸ¬³â–‘ğŸ¬´â–‘ğŸ¬µâ–‘ğŸ¬¶â–‘ğŸ¬·â–‘ğŸ¬¸â–‘ğŸ¬¹â–‘ğŸ¬ºâ–‘ğŸ¬»â–‘ğŸ¬¼â–‘ğŸ¬½â–‘ğŸ¬¾â–‘ğŸ¬¿â–‘â–‘
â–‘â–‘ğŸ­€â–‘ğŸ­â–‘ğŸ­‚â–‘ğŸ­ƒâ–‘ğŸ­„â–‘ğŸ­…â–‘ğŸ­†â–‘ğŸ­‡â–‘ğŸ­ˆâ–‘ğŸ­‰â–‘ğŸ­Šâ–‘ğŸ­‹â–‘ğŸ­Œâ–‘ğŸ­â–‘ğŸ­â–‘ğŸ­â–‘ğŸ­â–‘ğŸ­‘â–‘ğŸ­’â–‘ğŸ­“â–‘ğŸ­”â–‘ğŸ­•â–‘ğŸ­–â–‘ğŸ­—â–‘ğŸ­˜â–‘ğŸ­™â–‘ğŸ­šâ–‘ğŸ­›â–‘ğŸ­œâ–‘ğŸ­â–‘ğŸ­â–‘ğŸ­Ÿâ–‘
â–‘ğŸ­ â–‘ğŸ­¡â–‘ğŸ­¢â–‘ğŸ­£â–‘ğŸ­¤â–‘ğŸ­¥â–‘ğŸ­¦â–‘ğŸ­§â–‘ğŸ­¨â–‘ğŸ­©â–‘ğŸ­ªâ–‘ğŸ­«â–‘ğŸ­¬â–‘ğŸ­­â–‘ğŸ­®â–‘ğŸ­¯â–‘ğŸ­°â–‘ğŸ­±â–‘ğŸ­²â–‘ğŸ­³â–‘ğŸ­´â–‘ğŸ­µâ–‘ğŸ­¶â–‘ğŸ­·â–‘ğŸ­¸â–‘ğŸ­¹â–‘ğŸ­ºâ–‘ğŸ­»â–‘ğŸ­¼â–‘ğŸ­½â–‘ğŸ­¾â–‘ğŸ­¿â–‘â–‘
â–‘â–‘ğŸ®€â–‘ğŸ®â–‘ğŸ®‚â–‘ğŸ®ƒâ–‘ğŸ®„â–‘ğŸ®…â–‘ğŸ®†â–‘ğŸ®‡â–‘ğŸ®ˆâ–‘ğŸ®‰â–‘ğŸ®Šâ–‘ğŸ®‹â–‘ğŸ®Œâ–‘ğŸ®â–‘ğŸ®â–‘ğŸ®â–‘ğŸ®â–‘ğŸ®‘â–‘ğŸ®’â–‘ğŸ®”â–‘ğŸ®•â–‘ğŸ®–â–‘ğŸ®—â–‘ğŸ®˜â–‘ğŸ®™â–‘ğŸ®šâ–‘ğŸ®›â–‘ğŸ®œâ–‘ğŸ®â–‘ğŸ®â–‘ğŸ®Ÿâ–‘â–‘â–‘
â–‘ğŸ® â–‘ğŸ®¡â–‘ğŸ®¢â–‘ğŸ®£â–‘ğŸ®¤â–‘ğŸ®¥â–‘ğŸ®¦â–‘ğŸ®§â–‘ğŸ®¨â–‘ğŸ®©â–‘ğŸ®ªâ–‘ğŸ®«â–‘ğŸ®¬â–‘ğŸ®­â–‘ğŸ®®â–‘ğŸ®¯â–‘ğŸ®°â–‘ğŸ®±â–‘ğŸ®²â–‘ğŸ®³â–‘ğŸ®´â–‘ğŸ®µâ–‘ğŸ®¶â–‘ğŸ®·â–‘ğŸ®¸â–‘ğŸ®¹â–‘ğŸ®ºâ–‘ğŸ®»â–‘ğŸ®¼â–‘ğŸ®½â–‘ğŸ®¾â–‘ğŸ®¿â–‘â–‘
â–‘â–‘ğŸ¯€â–‘ğŸ¯â–‘ğŸ¯‚â–‘ğŸ¯ƒâ–‘ğŸ¯„â–‘ğŸ¯…â–‘ğŸ¯†â–‘ğŸ¯‡â–‘ğŸ¯ˆâ–‘ğŸ¯‰â–‘ğŸ¯Šâ–‘ğŸ¯‹â–‘ğŸ¯Œâ–‘ğŸ¯â–‘ğŸ¯â–‘ğŸ¯â–‘ğŸ¯â–‘ğŸ¯‘â–‘ğŸ¯’â–‘ğŸ¯“â–‘ğŸ¯”â–‘ğŸ¯•â–‘ğŸ¯–â–‘ğŸ¯—â–‘ğŸ¯˜â–‘ğŸ¯™â–‘ğŸ¯šâ–‘ğŸ¯›â–‘ğŸ¯œâ–‘ğŸ¯â–‘ğŸ¯â–‘ğŸ¯Ÿâ–‘
â–‘ğŸ¯ â–‘ğŸ¯¡â–‘ğŸ¯¢â–‘ğŸ¯£â–‘ğŸ¯¤â–‘ğŸ¯¥â–‘ğŸ¯¦â–‘ğŸ¯§â–‘ğŸ¯¨â–‘ğŸ¯©â–‘ğŸ¯ªâ–‘ğŸ¯«â–‘ğŸ¯¬â–‘ğŸ¯­â–‘ğŸ¯®â–‘ğŸ¯¯â–‘ğŸ¯°â–‘ğŸ¯±â–‘ğŸ¯²â–‘ğŸ¯³â–‘ğŸ¯´â–‘ğŸ¯µâ–‘ğŸ¯¶â–‘ğŸ¯·â–‘ğŸ¯¸â–‘ğŸ¯¹â–‘ğŸ¯ºâ–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘
â–‘â–‘ğœ°€â–‘ğœ°â–‘ğœ°‚â–‘ğœ°ƒâ–‘ğœ°„â–‘ğœ°…â–‘ğœ°†â–‘ğœ°‡â–‘ğœ°ˆâ–‘ğœ°‰â–‘ğœ°Šâ–‘ğœ°‹â–‘ğœ°Œâ–‘ğœ°â–‘ğœ°â–‘ğœ°â–‘ğœ°â–‘ğœ°‘â–‘ğœ°’â–‘ğœ°“â–‘ğœ°”â–‘ğœ°•â–‘ğœ°–â–‘ğœ°—â–‘ğœ°˜â–‘ğœ°™â–‘ğœ°šâ–‘ğœ°›â–‘ğœ°œâ–‘ğœ°â–‘ğœ°â–‘ğœ°Ÿâ–‘
â–‘ğœ° â–‘ğœ°¡â–‘ğœ°¢â–‘ğœ°£â–‘ğœ°¤â–‘ğœ°¥â–‘ğœ°¦â–‘ğœ°§â–‘ğœ°¨â–‘ğœ°©â–‘ğœ°ªâ–‘ğœ°«â–‘ğœ°¬â–‘ğœ°­â–‘ğœ°®â–‘ğœ°¯â–‘ğœ°°â–‘ğœ°±â–‘ğœ°²â–‘ğœ°³â–‘ğœ°´â–‘ğœ°µâ–‘ğœ°¶â–‘ğœ°·â–‘ğœ°¸â–‘ğœ°¹â–‘ğœ°ºâ–‘ğœ°»â–‘ğœ°¼â–‘ğœ°½â–‘ğœ°¾â–‘ğœ°¿â–‘â–‘
â–‘â–‘ğœ±€â–‘ğœ±â–‘ğœ±‚â–‘ğœ±ƒâ–‘ğœ±„â–‘ğœ±…â–‘ğœ±†â–‘ğœ±‡â–‘ğœ±ˆâ–‘ğœ±‰â–‘ğœ±Šâ–‘ğœ±‹â–‘ğœ±Œâ–‘ğœ±â–‘ğœ±â–‘ğœ±â–‘ğœ±â–‘ğœ±‘â–‘ğœ±’â–‘ğœ±“â–‘ğœ±”â–‘ğœ±•â–‘ğœ±–â–‘ğœ±—â–‘ğœ±˜â–‘ğœ±™â–‘ğœ±šâ–‘ğœ±›â–‘ğœ±œâ–‘ğœ±â–‘ğœ±â–‘ğœ±Ÿâ–‘
â–‘ğœ± â–‘ğœ±¡â–‘ğœ±¢â–‘ğœ±£â–‘ğœ±¤â–‘ğœ±¥â–‘ğœ±¦â–‘ğœ±§â–‘ğœ±¨â–‘ğœ±©â–‘ğœ±ªâ–‘ğœ±«â–‘ğœ±¬â–‘ğœ±­â–‘ğœ±®â–‘ğœ±¯â–‘ğœ±°â–‘ğœ±±â–‘ğœ±²â–‘ğœ±³â–‘ğœ±´â–‘ğœ±µâ–‘ğœ±¶â–‘ğœ±·â–‘ğœ±¸â–‘ğœ±¹â–‘ğœ±ºâ–‘ğœ±»â–‘ğœ±¼â–‘ğœ±½â–‘ğœ±¾â–‘ğœ±¿â–‘â–‘
â–‘â–‘ğœ²€â–‘ğœ²â–‘ğœ²‚â–‘ğœ²ƒâ–‘ğœ²„â–‘ğœ²…â–‘ğœ²†â–‘ğœ²‡â–‘ğœ²ˆâ–‘ğœ²‰â–‘ğœ²Šâ–‘ğœ²‹â–‘ğœ²Œâ–‘ğœ²â–‘ğœ²â–‘ğœ²â–‘ğœ²â–‘ğœ²‘â–‘ğœ²’â–‘ğœ²“â–‘ğœ²”â–‘ğœ²•â–‘ğœ²–â–‘ğœ²—â–‘ğœ²˜â–‘ğœ²™â–‘ğœ²šâ–‘ğœ²›â–‘ğœ²œâ–‘ğœ²â–‘ğœ²â–‘ğœ²Ÿâ–‘
â–‘ğœ² â–‘ğœ²¡â–‘ğœ²¢â–‘ğœ²£â–‘ğœ²¤â–‘ğœ²¥â–‘ğœ²¦â–‘ğœ²§â–‘ğœ²¨â–‘ğœ²©â–‘ğœ²ªâ–‘ğœ²«â–‘ğœ²¬â–‘ğœ²­â–‘ğœ²®â–‘ğœ²¯â–‘ğœ²°â–‘ğœ²±â–‘ğœ²²â–‘ğœ²³â–‘ğœ²´â–‘ğœ²µâ–‘ğœ²¶â–‘ğœ²·â–‘ğœ²¸â–‘ğœ²¹â–‘ğœ²ºâ–‘ğœ²»â–‘ğœ²¼â–‘ğœ²½â–‘ğœ²¾â–‘ğœ²¿â–‘â–‘
â–‘â–‘ğœ³€â–‘ğœ³â–‘ğœ³‚â–‘ğœ³ƒâ–‘ğœ³„â–‘ğœ³…â–‘ğœ³†â–‘ğœ³‡â–‘ğœ³ˆâ–‘ğœ³‰â–‘ğœ³Šâ–‘ğœ³‹â–‘ğœ³Œâ–‘ğœ³â–‘ğœ³â–‘ğœ³â–‘ğœ³â–‘ğœ³‘â–‘ğœ³’â–‘ğœ³“â–‘ğœ³”â–‘ğœ³•â–‘ğœ³–â–‘ğœ³—â–‘ğœ³˜â–‘ğœ³™â–‘ğœ³šâ–‘ğœ³›â–‘ğœ³œâ–‘ğœ³â–‘ğœ³â–‘ğœ³Ÿâ–‘
â–‘ğœ³ â–‘ğœ³¡â–‘ğœ³¢â–‘ğœ³£â–‘ğœ³¤â–‘ğœ³¥â–‘ğœ³¦â–‘ğœ³§â–‘ğœ³¨â–‘ğœ³©â–‘ğœ³ªâ–‘ğœ³«â–‘ğœ³¬â–‘ğœ³­â–‘ğœ³®â–‘ğœ³¯â–‘ğœ³°â–‘ğœ³±â–‘ğœ³²â–‘ğœ³³â–‘ğœ³´â–‘ğœ³µâ–‘ğœ³¶â–‘ğœ³·â–‘ğœ³¸â–‘ğœ³¹â–‘ğœ³ºâ–‘ğœ³»â–‘ğœ³¼â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘
â–‘â–‘ğœ´€â–‘ğœ´â–‘ğœ´‚â–‘ğœ´ƒâ–‘ğœ´„â–‘ğœ´…â–‘ğœ´†â–‘ğœ´‡â–‘ğœ´ˆâ–‘ğœ´‰â–‘ğœ´Šâ–‘ğœ´‹â–‘ğœ´Œâ–‘ğœ´â–‘ğœ´â–‘ğœ´â–‘ğœ´â–‘ğœ´‘â–‘ğœ´’â–‘ğœ´“â–‘ğœ´”â–‘ğœ´•â–‘ğœ´–â–‘ğœ´—â–‘ğœ´˜â–‘ğœ´™â–‘ğœ´šâ–‘ğœ´›â–‘ğœ´œâ–‘ğœ´â–‘ğœ´â–‘ğœ´Ÿâ–‘
â–‘ğœ´ â–‘ğœ´¡â–‘ğœ´¢â–‘ğœ´£â–‘ğœ´¤â–‘ğœ´¥â–‘ğœ´¦â–‘ğœ´§â–‘ğœ´¨â–‘ğœ´©â–‘ğœ´ªâ–‘ğœ´«â–‘ğœ´¬â–‘ğœ´­â–‘ğœ´®â–‘ğœ´¯â–‘ğœ´°â–‘ğœ´±â–‘ğœ´²â–‘ğœ´³â–‘ğœ´´â–‘ğœ´µâ–‘ğœ´¶â–‘ğœ´·â–‘ğœ´¸â–‘ğœ´¹â–‘ğœ´ºâ–‘ğœ´»â–‘ğœ´¼â–‘ğœ´½â–‘ğœ´¾â–‘ğœ´¿â–‘â–‘
â–‘â–‘ğœµ€â–‘ğœµâ–‘ğœµ‚â–‘ğœµƒâ–‘ğœµ„â–‘ğœµ…â–‘ğœµ†â–‘ğœµ‡â–‘ğœµˆâ–‘ğœµ‰â–‘ğœµŠâ–‘ğœµ‹â–‘ğœµŒâ–‘ğœµâ–‘ğœµâ–‘ğœµâ–‘ğœµâ–‘ğœµ‘â–‘ğœµ’â–‘ğœµ“â–‘ğœµ”â–‘ğœµ•â–‘ğœµ–â–‘ğœµ—â–‘ğœµ˜â–‘ğœµ™â–‘ğœµšâ–‘ğœµ›â–‘ğœµœâ–‘ğœµâ–‘ğœµâ–‘ğœµŸâ–‘
â–‘ğœµ â–‘ğœµ¡â–‘ğœµ¢â–‘ğœµ£â–‘ğœµ¤â–‘ğœµ¥â–‘ğœµ¦â–‘ğœµ§â–‘ğœµ¨â–‘ğœµ©â–‘ğœµªâ–‘ğœµ«â–‘ğœµ¬â–‘ğœµ­â–‘ğœµ®â–‘ğœµ¯â–‘ğœµ°â–‘ğœµ±â–‘ğœµ²â–‘ğœµ³â–‘ğœµ´â–‘ğœµµâ–‘ğœµ¶â–‘ğœµ·â–‘ğœµ¸â–‘ğœµ¹â–‘ğœµºâ–‘ğœµ»â–‘ğœµ¼â–‘ğœµ½â–‘ğœµ¾â–‘ğœµ¿â–‘â–‘
â–‘â–‘ğœ¶€â–‘ğœ¶â–‘ğœ¶‚â–‘ğœ¶ƒâ–‘ğœ¶„â–‘ğœ¶…â–‘ğœ¶†â–‘ğœ¶‡â–‘ğœ¶ˆâ–‘ğœ¶‰â–‘ğœ¶Šâ–‘ğœ¶‹â–‘ğœ¶Œâ–‘ğœ¶â–‘ğœ¶â–‘ğœ¶â–‘ğœ¶â–‘ğœ¶‘â–‘ğœ¶’â–‘ğœ¶“â–‘ğœ¶”â–‘ğœ¶•â–‘ğœ¶–â–‘ğœ¶—â–‘ğœ¶˜â–‘ğœ¶™â–‘ğœ¶šâ–‘ğœ¶›â–‘ğœ¶œâ–‘ğœ¶â–‘ğœ¶â–‘ğœ¶Ÿâ–‘
â–‘ğœ¶ â–‘ğœ¶¡â–‘ğœ¶¢â–‘ğœ¶£â–‘ğœ¶¤â–‘ğœ¶¥â–‘ğœ¶¦â–‘ğœ¶§â–‘ğœ¶¨â–‘ğœ¶©â–‘ğœ¶ªâ–‘ğœ¶«â–‘ğœ¶¬â–‘ğœ¶­â–‘ğœ¶®â–‘ğœ¶¯â–‘ğœ¶°â–‘ğœ¶±â–‘ğœ¶²â–‘ğœ¶³â–‘ğœ¶´â–‘ğœ¶µâ–‘ğœ¶¶â–‘ğœ¶·â–‘ğœ¶¸â–‘ğœ¶¹â–‘ğœ¶ºâ–‘ğœ¶»â–‘ğœ¶¼â–‘ğœ¶½â–‘ğœ¶¾â–‘ğœ¶¿â–‘â–‘
â–‘â–‘ğœ·€â–‘ğœ·â–‘ğœ·‚â–‘ğœ·ƒâ–‘ğœ·„â–‘ğœ·…â–‘ğœ·†â–‘ğœ·‡â–‘ğœ·ˆâ–‘ğœ·‰â–‘ğœ·Šâ–‘ğœ·‹â–‘ğœ·Œâ–‘ğœ·â–‘ğœ·â–‘ğœ·â–‘ğœ·â–‘ğœ·‘â–‘ğœ·’â–‘ğœ·“â–‘ğœ·”â–‘ğœ·•â–‘ğœ·–â–‘ğœ·—â–‘ğœ·˜â–‘ğœ·™â–‘ğœ·šâ–‘ğœ·›â–‘ğœ·œâ–‘ğœ·â–‘ğœ·â–‘ğœ·Ÿâ–‘
â–‘ğœ· â–‘ğœ·¡â–‘ğœ·¢â–‘ğœ·£â–‘ğœ·¤â–‘ğœ·¥â–‘ğœ·¦â–‘ğœ·§â–‘ğœ·¨â–‘ğœ·©â–‘ğœ·ªâ–‘ğœ·«â–‘ğœ·¬â–‘ğœ·­â–‘ğœ·®â–‘ğœ·¯â–‘ğœ·°â–‘ğœ·±â–‘ğœ·²â–‘ğœ·³â–‘ğœ·´â–‘ğœ·µâ–‘ğœ·¶â–‘ğœ··â–‘ğœ·¸â–‘ğœ·¹â–‘ğœ·ºâ–‘ğœ·»â–‘ğœ·¼â–‘ğœ·½â–‘ğœ·¾â–‘ğœ·¿â–‘â–‘
â–‘â–‘ğœ¸€â–‘ğœ¸â–‘ğœ¸‚â–‘ğœ¸ƒâ–‘ğœ¸„â–‘ğœ¸…â–‘ğœ¸†â–‘ğœ¸‡â–‘ğœ¸ˆâ–‘ğœ¸‰â–‘ğœ¸Šâ–‘ğœ¸‹â–‘ğœ¸Œâ–‘ğœ¸â–‘ğœ¸â–‘ğœ¸â–‘ğœ¸â–‘ğœ¸‘â–‘ğœ¸’â–‘ğœ¸“â–‘ğœ¸”â–‘ğœ¸•â–‘ğœ¸–â–‘ğœ¸—â–‘ğœ¸˜â–‘ğœ¸™â–‘ğœ¸šâ–‘ğœ¸›â–‘ğœ¸œâ–‘ğœ¸â–‘ğœ¸â–‘ğœ¸Ÿâ–‘
â–‘ğœ¸ â–‘ğœ¸¡â–‘ğœ¸¢â–‘ğœ¸£â–‘ğœ¸¤â–‘ğœ¸¥â–‘ğœ¸¦â–‘ğœ¸§â–‘ğœ¸¨â–‘ğœ¸©â–‘ğœ¸ªâ–‘ğœ¸«â–‘ğœ¸¬â–‘ğœ¸­â–‘ğœ¸®â–‘ğœ¸¯â–‘ğœ¸°â–‘ğœ¸±â–‘ğœ¸²â–‘ğœ¸³â–‘ğœ¸´â–‘ğœ¸µâ–‘ğœ¸¶â–‘ğœ¸·â–‘ğœ¸¸â–‘ğœ¸¹â–‘ğœ¸ºâ–‘ğœ¸»â–‘ğœ¸¼â–‘ğœ¸½â–‘ğœ¸¾â–‘ğœ¸¿â–‘â–‘
â–‘â–‘ğœ¹€â–‘ğœ¹â–‘ğœ¹‚â–‘ğœ¹ƒâ–‘ğœ¹„â–‘ğœ¹…â–‘ğœ¹†â–‘ğœ¹‡â–‘ğœ¹ˆâ–‘ğœ¹‰â–‘ğœ¹Šâ–‘ğœ¹‹â–‘ğœ¹Œâ–‘ğœ¹â–‘ğœ¹â–‘ğœ¹â–‘ğœ¹â–‘ğœ¹‘â–‘ğœ¹’â–‘ğœ¹“â–‘ğœ¹”â–‘ğœ¹•â–‘ğœ¹–â–‘ğœ¹—â–‘ğœ¹˜â–‘ğœ¹™â–‘ğœ¹šâ–‘ğœ¹›â–‘ğœ¹œâ–‘ğœ¹â–‘ğœ¹â–‘ğœ¹Ÿâ–‘
â–‘ğœ¹ â–‘ğœ¹¡â–‘ğœ¹¢â–‘ğœ¹£â–‘ğœ¹¤â–‘ğœ¹¥â–‘ğœ¹¦â–‘ğœ¹§â–‘ğœ¹¨â–‘ğœ¹©â–‘ğœ¹ªâ–‘ğœ¹«â–‘ğœ¹¬â–‘ğœ¹­â–‘ğœ¹®â–‘ğœ¹¯â–‘ğœ¹°â–‘ğœ¹±â–‘ğœ¹²â–‘ğœ¹³â–‘ğœ¹´â–‘ğœ¹µâ–‘ğœ¹¶â–‘ğœ¹·â–‘ğœ¹¸â–‘ğœ¹¹â–‘ğœ¹ºâ–‘ğœ¹»â–‘ğœ¹¼â–‘ğœ¹½â–‘ğœ¹¾â–‘ğœ¹¿â–‘â–‘
â–‘â–‘ğœº€â–‘ğœºâ–‘ğœº‚â–‘ğœºƒâ–‘ğœº„â–‘ğœº…â–‘ğœº†â–‘ğœº‡â–‘ğœºˆâ–‘ğœº‰â–‘ğœºŠâ–‘ğœº‹â–‘ğœºŒâ–‘ğœºâ–‘ğœºâ–‘ğœºâ–‘ğœºâ–‘ğœº‘â–‘ğœº’â–‘ğœº“â–‘ğœº”â–‘ğœº•â–‘ğœº–â–‘ğœº—â–‘ğœº˜â–‘ğœº™â–‘ğœºšâ–‘ğœº›â–‘ğœºœâ–‘ğœºâ–‘ğœºâ–‘ğœºŸâ–‘
â–‘ğœº â–‘ğœº¡â–‘ğœº¢â–‘ğœº£â–‘ğœº¤â–‘ğœº¥â–‘ğœº¦â–‘ğœº§â–‘ğœº¨â–‘ğœº©â–‘ğœºªâ–‘ğœº«â–‘ğœº¬â–‘ğœº­â–‘ğœº®â–‘ğœº¯â–‘ğœº°â–‘ğœº±â–‘ğœº²â–‘ğœº³â–‘ğœººâ–‘ğœº»â–‘ğœº¼â–‘ğœº½â–‘ğœº¾â–‘ğœº¿â–‘
*/


struct WeeString {
    static constexpr int kMaxLen = 7;
    constexpr WeeString() : data_{}, len_{0} {}
    constexpr WeeString(wchar_t c) : data_{} {
        if (c < 0x80) {
            data_[0] = c;
            data_[1] = '\0';
            len_ = 1;
        } else if (c < 0x800) {
            data_[0] = 0xc0 | (c >> 6);
            data_[1] = 0x80 | ((c >> 0) & 0x3f);
            data_[2] = '\0';
            len_ = 2;
        } else if (c < 0x10000) {
            data_[0] = 0xe0 | (c >> 12);
            data_[1] = 0x80 | ((c >> 6) & 0x3f);
            data_[2] = 0x80 | ((c >> 0) & 0x3f);
            data_[3] = '\0';
            len_ = 3;
        } else {
            data_[0] = 0xf0 | (c >> 18);
            data_[1] = 0x80 | ((c >> 12) & 0x3f);
            data_[2] = 0x80 | ((c >> 6) & 0x3f);
            data_[3] = 0x80 | ((c >> 0) & 0x3f);
            data_[4] = '\0';
            len_ = 4;
        }
    }

    operator char const*() const {
        return data_;
    }
    operator std::string_view() const {
        std::string_view r{data_, len_};
        std::cerr << r << std::endl;
        return r;
    }

  private:
    char data_[kMaxLen];
    uint8_t len_;
};

struct Glyph {
    static constexpr int kMaxWidth = 8;
    static constexpr int kMaxHeight = 16;

    Glyph(int height = 8, int width = 8, bool hflip = true, int shift = 0)
            : width_(width), height_(height), hflip_(hflip), shift_(shift) {
        assert(width <= kMaxWidth);
        assert(height <= kMaxHeight);
    }
    long read(FILE* file) {
        long position = ftell(file);
        if (fread(blob_, height_, 1, file) != 1) return -1;
        if (hflip_) hflip();
        return position;
    }
    template <size_t W, size_t H>
    uint64_t get_bitmap(int line, int col) const {
        constexpr uint64_t mask = ~(~uint64_t(1) << (W - 1));
        uint64_t bitmap = 0;
        for (int i = 0, s = 0; i < H; ++i, s += W) {
            int j = i + line;
            if (0 <= j && j < height_) {
                uint64_t b = uint64_t(blob_[j]) << 8 >> (col + 8);
                bitmap |= (b & mask) << s;
            }
        }
        return bitmap;
    }
    void hflip() {
        for (int i = 0; i < height_; ++i) {
            int x = blob_[i];
            x = ((x >> 1) & 0x55) | ((x & 0x55) << 1);
            x = ((x >> 2) & 0x33) | ((x & 0x33) << 2);
            x = ((x >> 4) & 0x0f) | ((x & 0x0f) << 4);
            blob_[i] = x >> shift_;
        }
    }

    const int width_;
    const int height_;
    const bool hflip_;
    const int shift_;
    uint8_t blob_[kMaxHeight];
};

template <size_t W, size_t H>
struct Patcher {
    constexpr Patcher(char const* s, wchar_t code) : code_(code) {
        mask_ = 0;
        test_ = 0;
        uint64_t b = 1;
        while (*s) {
            mask_ |= (*s == ' ' || *s == '@') ? b : 0;
            test_ |= (*s == '@') ? b : 0;
            b <<= 1;
            s++;
        }
    }

    uint64_t mask_, test_;
    WeeString code_;
};

template <size_t W, size_t H>
struct Decoder {
    static constexpr size_t PW = W + 2;
    static constexpr size_t PH = H + 2;
    using PatchType = Patcher<PW, PH>;
    constexpr Decoder(wchar_t const* ptr, std::span<const PatchType> patches = std::span<const PatchType>{})
            : patches_(patches) {
        for (WeeString& g : glyphs_) {
            assert(*ptr != '\0');
            g = *ptr++;
        }
        assert(*ptr == '\0');
    }

    bool decode(std::string& out, auto const& glyph, int row = 0) const {
        for (int col = 0; col < glyph.width_; col += W) {
            uint64_t bitmap = glyph.template get_bitmap<PW, PH>(row * H - 1, col - 1);
            bool match = false;
            for (auto p : patches_) {
                if ((bitmap & p.mask_) == p.test_) {
                    out += p.code_;
                    match = true;
                    break;
                }
            }
            if (match) continue;
            int j = glyph.template get_bitmap<W, H>(row * H, col);
            assert(0 <= j && j < kMapSize);
            out += glyphs_[j];
        }
        return (row + 1) * H < glyph.height_;
    }

  private:
    static constexpr size_t kMapSize = size_t(1) << (W * H);
    WeeString glyphs_[kMapSize];
    std::span<const PatchType> patches_{};
};

struct CharSetBase {
    virtual void insert(wchar_t code, Glyph const& glyph, bool replace = true) = 0;
    virtual bool decode(std::string& out, Glyph const& glyph, int row) const = 0;
    CharSetBase(std::string_view name) : name_(name) {}
    size_t count(wchar_t code) {
        return chars_.count(code);
    }
    virtual int get_rows(Glyph const& glyph) = 0;

    std::string_view get(wchar_t code) {
        if (count(code) == 0) return chars_[' '];
        return chars_[code];
    }
    auto begin() { return chars_.begin(); }
    auto end() { return chars_.end(); }

    std::string const name_;
    std::map<wchar_t, std::string> chars_;
};

template <int W, int H>
struct CharSet : public CharSetBase {
    CharSet(std::string_view name, Decoder<W, H> const& decoder)
        : CharSetBase(name), decoder_(decoder) { }

    void insert(wchar_t code, Glyph const& glyph, bool replace) override {
        if (replace == false && chars_.count(code)) return;
        std::string image;
        for (int row = 0; decoder_.decode(image, glyph, row); ++row) {
            image += "#\n";
        }
        image += "##\n";
        chars_[code] = image;
    }
    bool decode(std::string& out, Glyph const& glyph, int row) const override {
        return decoder_.decode(out, glyph, row);
    }
    int get_rows(Glyph const& glyph) override { return (glyph.height_ - 1) / H + 1; }

    Decoder<W, H> const& decoder_;
};


static constexpr wchar_t braille_data[] =
   L"â €â â ˆâ ‰â ‚â ƒâ Šâ ‹â â ‘â ˜â ™â ’â “â šâ ›"
    "â „â …â Œâ â †â ‡â â â ”â •â œâ â –â —â â Ÿ"
    "â  â ¡â ¨â ©â ¢â £â ªâ «â °â ±â ¸â ¹â ²â ³â ºâ »"
    "â ¤â ¥â ¬â ­â ¦â §â ®â ¯â ´â µâ ¼â ½â ¶â ·â ¾â ¿"
    "â¡€â¡â¡ˆâ¡‰â¡‚â¡ƒâ¡Šâ¡‹â¡â¡‘â¡˜â¡™â¡’â¡“â¡šâ¡›"
    "â¡„â¡…â¡Œâ¡â¡†â¡‡â¡â¡â¡”â¡•â¡œâ¡â¡–â¡—â¡â¡Ÿ"
    "â¡ â¡¡â¡¨â¡©â¡¢â¡£â¡ªâ¡«â¡°â¡±â¡¸â¡¹â¡²â¡³â¡ºâ¡»"
    "â¡¤â¡¥â¡¬â¡­â¡¦â¡§â¡®â¡¯â¡´â¡µâ¡¼â¡½â¡¶â¡·â¡¾â¡¿"
    "â¢€â¢â¢ˆâ¢‰â¢‚â¢ƒâ¢Šâ¢‹â¢â¢‘â¢˜â¢™â¢’â¢“â¢šâ¢›"
    "â¢„â¢…â¢Œâ¢â¢†â¢‡â¢â¢â¢”â¢•â¢œâ¢â¢–â¢—â¢â¢Ÿ"
    "â¢ â¢¡â¢¨â¢©â¢¢â¢£â¢ªâ¢«â¢°â¢±â¢¸â¢¹â¢²â¢³â¢ºâ¢»"
    "â¢¤â¢¥â¢¬â¢­â¢¦â¢§â¢®â¢¯â¢´â¢µâ¢¼â¢½â¢¶â¢·â¢¾â¢¿"
    "â£€â£â£ˆâ£‰â£‚â£ƒâ£Šâ£‹â£â£‘â£˜â£™â£’â£“â£šâ£›"
    "â£„â£…â£Œâ£â£†â£‡â£â£â£”â£•â£œâ£â£–â£—â£â£Ÿ"
    "â£ â£¡â£¨â£©â£¢â££â£ªâ£«â£°â£±â£¸â£¹â£²â£³â£ºâ£»"
    "â£¤â£¥â£¬â£­â£¦â£§â£®â£¯â£´â£µâ£¼â£½â£¶â£·â£¾â£¿";

static constexpr wchar_t braille6_data[] =
   L"â€‡ğœ¹‘ğœ¹’ğœ¹“ğœ¹”ğœ¹•ğœ¹–ğœ¹—ğœ¹˜ğœ¹™ğœ¹šğœ¹›ğœ¹œğœ¹ğœ¹ğœ¹Ÿ"
    "ğœ¹ ğœ¹¡ğœ¹¢ğœ¹£ğœ¹¤ğœ¹¥ğœ¹¦ğœ¹§ğœ¹¨ğœ¹©ğœ¹ªğœ¹«ğœ¹¬ğœ¹­ğœ¹®ğœ¹¯"
    "ğœ¹°ğœ¹±ğœ¹²ğœ¹³ğœ¹´ğœ¹µğœ¹¶ğœ¹·ğœ¹¸ğœ¹¹ğœ¹ºğœ¹»ğœ¹¼ğœ¹½ğœ¹¾ğœ¹¿"
    "ğœº€ğœºğœº‚ğœºƒğœº„ğœº…ğœº†ğœº‡ğœºˆğœº‰ğœºŠğœº‹ğœºŒğœºğœºğœº";

static constexpr wchar_t braille4_data[] =
   L"â€‡ğœ°¡ğœ°¢ğœ°£ğœ°¤ğœ°¥ğœ°¦ğœ°§ğœ°¨ğœ°©ğœ°ªğœ°«ğœ°¬ğœ°­ğœ°®ğœ°¯";

static constexpr wchar_t block_data[] =
   L"â€‡ğœº¨ğœº«ğŸ®‚ğœ´€â–˜ğœ´ğœ´‚ğœ´ƒğœ´„â–ğœ´…ğœ´†ğœ´‡ğœ´ˆâ–€"
    "ğœ´‰ğœ´Šğœ´‹ğœ´ŒğŸ¯¦ğœ´ğœ´ğœ´ğœ´ğœ´‘ğœ´’ğœ´“ğœ´”ğœ´•ğœ´–ğœ´—"
    "ğœ´˜ğœ´™ğœ´šğœ´›ğœ´œğœ´ğœ´ğœ´ŸğŸ¯§ğœ´ ğœ´¡ğœ´¢ğœ´£ğœ´¤ğœ´¥ğœ´¦"
    "ğœ´§ğœ´¨ğœ´©ğœ´ªğœ´«ğœ´¬ğœ´­ğœ´®ğœ´¯ğœ´°ğœ´±ğœ´²ğœ´³ğœ´´ğœ´µğŸ®…"
    "ğœº£ğœ´¶ğœ´·ğœ´¸ğœ´¹ğœ´ºğœ´»ğœ´¼ğœ´½ğœ´¾ğœ´¿ğœµ€ğœµğœµ‚ğœµƒğœµ„"
    "â––ğœµ…ğœµ†ğœµ‡ğœµˆâ–Œğœµ‰ğœµŠğœµ‹ğœµŒâ–ğœµğœµğœµğœµâ–›"
    "ğœµ‘ğœµ’ğœµ“ğœµ”ğœµ•ğœµ–ğœµ—ğœµ˜ğœµ™ğœµšğœµ›ğœµœğœµğœµğœµŸğœµ "
    "ğœµ¡ğœµ¢ğœµ£ğœµ¤ğœµ¥ğœµ¦ğœµ§ğœµ¨ğœµ©ğœµªğœµ«ğœµ¬ğœµ­ğœµ®ğœµ¯ğœµ°"
    "ğœº ğœµ±ğœµ²ğœµ³ğœµ´ğœµµğœµ¶ğœµ·ğœµ¸ğœµ¹ğœµºğœµ»ğœµ¼ğœµ½ğœµ¾ğœµ¿"
    "ğœ¶€ğœ¶ğœ¶‚ğœ¶ƒğœ¶„ğœ¶…ğœ¶†ğœ¶‡ğœ¶ˆğœ¶‰ğœ¶Šğœ¶‹ğœ¶Œğœ¶ğœ¶ğœ¶"
    "â–—ğœ¶ğœ¶‘ğœ¶’ğœ¶“â–šğœ¶”ğœ¶•ğœ¶–ğœ¶—â–ğœ¶˜ğœ¶™ğœ¶šğœ¶›â–œ"
    "ğœ¶œğœ¶ğœ¶ğœ¶Ÿğœ¶ ğœ¶¡ğœ¶¢ğœ¶£ğœ¶¤ğœ¶¥ğœ¶¦ğœ¶§ğœ¶¨ğœ¶©ğœ¶ªğœ¶«"
    "â–‚ğœ¶¬ğœ¶­ğœ¶®ğœ¶¯ğœ¶°ğœ¶±ğœ¶²ğœ¶³ğœ¶´ğœ¶µğœ¶¶ğœ¶·ğœ¶¸ğœ¶¹ğœ¶º"
    "ğœ¶»ğœ¶¼ğœ¶½ğœ¶¾ğœ¶¿ğœ·€ğœ·ğœ·‚ğœ·ƒğœ·„ğœ·…ğœ·†ğœ·‡ğœ·ˆğœ·‰ğœ·Š"
    "ğœ·‹ğœ·Œğœ·ğœ·ğœ·ğœ·ğœ·‘ğœ·’ğœ·“ğœ·”ğœ·•ğœ·–ğœ·—ğœ·˜ğœ·™ğœ·š"
    "â–„ğœ·›ğœ·œğœ·ğœ·â–™ğœ·Ÿğœ· ğœ·¡ğœ·¢â–Ÿğœ·£â–†ğœ·¤ğœ·¥â–ˆ";

static constexpr wchar_t block6_data[] =
   L"â€‡ğŸ¬€ğŸ¬ğŸ¬‚ğŸ¬ƒğŸ¬„ğŸ¬…ğŸ¬†ğŸ¬‡ğŸ¬ˆğŸ¬‰ğŸ¬ŠğŸ¬‹ğŸ¬ŒğŸ¬ğŸ¬"
    "ğŸ¬ğŸ¬ğŸ¬‘ğŸ¬’ğŸ¬“â–ŒğŸ¬”ğŸ¬•ğŸ¬–ğŸ¬—ğŸ¬˜ğŸ¬™ğŸ¬šğŸ¬›ğŸ¬œğŸ¬"
    "ğŸ¬ğŸ¬ŸğŸ¬ ğŸ¬¡ğŸ¬¢ğŸ¬£ğŸ¬¤ğŸ¬¥ğŸ¬¦ğŸ¬§â–ğŸ¬¨ğŸ¬©ğŸ¬ªğŸ¬«ğŸ¬¬"
    "ğŸ¬­ğŸ¬®ğŸ¬¯ğŸ¬°ğŸ¬±ğŸ¬²ğŸ¬³ğŸ¬´ğŸ¬µğŸ¬¶ğŸ¬·ğŸ¬¸ğŸ¬¹ğŸ¬ºğŸ¬»â–ˆ";

static constexpr wchar_t block4_data[] =
   L"â€‡â–˜â–â–€â––â–Œâ–â–›â–—â–šâ–â–œâ–„â–™â–Ÿâ–ˆ";

static constexpr wchar_t block2_data[] =
   L"â€‡â–€â–„â–ˆ";

static constexpr Patcher<3,4> block2_shadow_data[]{
    { "@.."
      "@ ."
      ". ."
      "...", L'â–’' },
    { "@.."
      "  ."
      ". ."
      "...", L'ğŸ®' },
    { " .."
      "@ ."
      ". ."
      "...", L'ğŸ®' },
    { "..."
      "@@."
      ". ."
      "...", L'ğŸ®‘' },
    { "@.."
      ". ."
      ".@."
      "...", L'ğŸ®’' },
};

const Decoder<2,4> braille(braille_data);
const Decoder<2,3> braille6(braille6_data);
const Decoder<2,2> braille4(braille4_data);
const Decoder<2,4> block(block_data);
const Decoder<2,3> block6(block6_data);
const Decoder<2,2> block4(block4_data);
const Decoder<1,2> block2(block2_data);
const Decoder<1,2> block2shadow(block2_data, block2_shadow_data);

CharSet<2,4> dots2x4("2dot", braille);
CharSet<2,3> dots2x3("3dot", braille6);
CharSet<2,2> dots2x2("4dot", braille4);
CharSet<2,4> blocks2x4("2", block);
CharSet<2,3> blocks2x3("3", block6);
CharSet<2,2> blocks2x2("4", block4);
CharSet<1,2> blocks1x2("4wide", block2);
CharSet<1,2> blocks1x2shadow("4shadow", block2shadow);

CharSetBase* allsets[] = {
    &dots2x4,
    &dots2x3,
    &dots2x2,
    &blocks2x4,
    &blocks2x3,
    &blocks2x2,
    &blocks1x2,
    &blocks1x2shadow,
};

int main(int argc, char** argv) {
    std::filesystem::path input = "c64.bin";
    std::filesystem::path output;
    std::filesystem::path mapfile;
    int seek = 0, shift = 0;
    int width = 8, height = 8;
    bool view = false, flip = true;

    int opt;
    while ((opt = getopt(argc, argv, "vW:H:S:Mk:m:i:o:")) != -1) {
        switch (opt) {
        case 'v':
            view = true;
            break;
        case 'W':
            width = atoi(optarg);
            break;
        case 'H':
            height = atoi(optarg);
            break;
        case 'S':
            shift = atoi(optarg);
            break;
        case 'M':
            flip = !flip;
            break;
        case 'k':
            seek = strtoul(optarg, nullptr, 0);
        case 'm':
            mapfile = optarg;
            break;
        case 'i':
            input = optarg;
            break;
        case 'o':
            output = optarg;
            break;
        default:
            std::cerr << "oops, bad command line argument." << std::endl;
            exit(EXIT_FAILURE);
        }
    }

    if (mapfile.empty()) {
        mapfile = input;
        mapfile.replace_extension(".map");
    }
    if (output.empty()) output = input.stem();
    std::string base = output.filename();

    FILE* blob = fopen(input.c_str(), "rb");
    if (blob == nullptr) {
        perror(input.c_str());
        exit(EXIT_FAILURE);
    }
    if (seek) fseek(blob, seek, SEEK_SET);
    FILE* map = fopen(mapfile.c_str(), "rt");

    Glyph glyph(height, width, flip, shift);
    wchar_t code = 32;
    long position;
    while ((position = glyph.read(blob)) >= 0) {
        if (map != nullptr) {
            char metadata[1024];
            fgets(metadata, sizeof(metadata), map);
            if (metadata[0] == 'U' && metadata[1] == '+') {
                code = strtoull(metadata + 2, nullptr, 16);
            } else {
                code = 0;
            }
        }
        if (code > 0 && !view) {
            for (auto set : allsets) {
                set->insert(code, glyph);
            }
        } else {
            std::string dump;
            bool more = true;
            for (int row = 0; more == true; ++row) {
                more = false;
                for (auto set : allsets) {
                    more |= set->decode(dump, glyph, row);
                    dump += "  ";
                }
                dump += '\n';
            }
            std::cout << "unused @0x" << std::hex << position << std::dec << ":\n" << dump;
        }
        code++;
    }
    if (!view) {
        std::string cmdline;
        for (int i = 0; i < argc; ++i) {
            cmdline += " ";
            cmdline += argv[i];
        }
        for (auto set : allsets) {
            auto filename = output;
            filename.replace_filename(std::string(output.filename()) + "-" + set->name_);
            filename.replace_extension(".tlf");
            FILE* font = fopen(filename.c_str(), "wt");
            if (font == nullptr) {
                perror(filename.c_str());
                continue;
            }
            fprintf(font, "tlf2a$ %d %d 40 -1 1 0 0 0\n"
                          "#%s (set: %s)\n",
                          set->get_rows(glyph), set->get_rows(glyph), cmdline.c_str(), set->name_.c_str());

            for (wchar_t code = 32; code < 127; ++code) {
                auto s = set->get(code);
                fwrite(s.data(), 1, s.size(), font);
            }
            for (wchar_t code : L"Ã„Ã–ÃœÃ¤Ã¶Ã¼ÃŸ") {
                if (code == L'\0') continue;
                auto s = set->get(code);
                fwrite(s.data(), 1, s.size(), font);
            }

            for (auto it : *set) {
                if (it.first < 127 || wcschr(L"Ã„Ã–ÃœÃ¤Ã¶Ã¼ÃŸ", it.first)) {
                    continue;
                }
                fprintf(font, "0x%06x\n%.*s", it.first, int(it.second.size()), it.second.data());
            }
            fclose(font);
        }
    }
    if (blob != nullptr) fclose(blob);
    if (map != nullptr) fclose(map);
    return 0;
}
